package rms.view.item;

import java.awt.Color;
import java.awt.Component;
import java.awt.Container;
import java.awt.KeyboardFocusManager;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.util.ArrayList;
import java.util.EventObject;
import java.util.Objects;
import javax.swing.JButton;
import javax.swing.Timer;
import javax.swing.UIDefaults;
import rms.model.item.TextItem;
import rms.view.util.UndoRedoProvider;

/**
 *
 * @author Timothy
 */
public class EditableTextField extends javax.swing.JPanel {

    private static final String SAVE = "Save";
    private static final String EDIT = "Edit";

    private final JButton saveEditButton;
    private String lastSavedText;//'null' is allowed, visually same as empty

    /**
     * No-arg constructor for Bean creation. NOTE: Do not use.
     */
    public EditableTextField() {
        saveEditButton = null;
        lastSavedText = null;
        initComponents();
    }

    /**
     * Creates new form EditableTextField
     *
     * @param text
     * @param saveEditButton
     */
    public EditableTextField(String text, JButton saveEditButton) {
        if (saveEditButton == null) {
            throw new IllegalArgumentException();
        }
        this.lastSavedText = text;
        this.saveEditButton = saveEditButton;
        initComponents();

        jTextPaneDesc.setText(text);
        //NOTE: makeEditable(..) calls preserveSize() so no need to do it right
        //  after setText(..) as would normally be required.
        makeEditable(false);

        UndoRedoProvider.addTo(jTextPaneDesc);
        saveEditButton.addActionListener(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent evt) {
                final String txt = EditableTextField.this.saveEditButton.getText();
                switch (txt) {
                    case SAVE:
                        saveAction();
                        break;
                    case EDIT:
                        editAction();
                        break;
                    default:
                        throw new IllegalStateException("Invalid button text: " + txt);
                }
            }
        });
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jTextPaneDesc = new javax.swing.JTextPane();

        setPreferredSize(new java.awt.Dimension(6, 22));

        jTextPaneDesc.setEditorKit(new rms.view.util.CustomEditorKit(36));
        jTextPaneDesc.addFocusListener(new java.awt.event.FocusAdapter() {
            public void focusLost(java.awt.event.FocusEvent evt) {
                jTextPaneDescFocusLost(evt);
            }
        });
        jTextPaneDesc.addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyTyped(java.awt.event.KeyEvent evt) {
                jTextPaneDescKeyTyped(evt);
            }
        });

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jTextPaneDesc)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jTextPaneDesc)
        );
    }// </editor-fold>//GEN-END:initComponents

    private void jTextPaneDescFocusLost(java.awt.event.FocusEvent evt) {//GEN-FIRST:event_jTextPaneDescFocusLost
        if (evt.getOppositeComponent() != saveEditButton) {//already handled in that case
            saveAction();
        }
    }//GEN-LAST:event_jTextPaneDescFocusLost

    private void jTextPaneDescKeyTyped(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_jTextPaneDescKeyTyped
        preserveSize();
    }//GEN-LAST:event_jTextPaneDescKeyTyped

    private void editAction() {
        makeEditable(true);

        //Try requesting focus every 5 ms until successful
        final Timer focusTimer = new Timer(5, null);
        focusTimer.addActionListener(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
                if (jTextPaneDesc.requestFocusInWindow()) {
                    focusTimer.stop();
                }
            }
        });
        focusTimer.start();
    }

    private void saveAction() {
        makeEditable(false);

        String newText = jTextPaneDesc.getText();
        if (!Objects.equals(this.lastSavedText, newText)) {
            this.lastSavedText = newText;
            fireItemTextUpdatedEvent(newText);
        }
    }

    private void makeEditable(boolean editable) {
        saveEditButton.setText(editable ? SAVE : EDIT);
        changeDescPaneColor(editable ? Color.WHITE : Color.LIGHT_GRAY);
        jTextPaneDesc.setEditable(editable);
        preserveSize();
    }

    private void changeDescPaneColor(Color c) {
        UIDefaults defaults = new UIDefaults();
        defaults.put("TextPane[Enabled].backgroundPainter", c);
        jTextPaneDesc.putClientProperty("Nimbus.Overrides", defaults);
        jTextPaneDesc.putClientProperty("Nimbus.Overrides.InheritDefaults", true);
        jTextPaneDesc.setBackground(c);
    }

    /**
     * There is a bug that causes the {@link javax.swing.JTextPane} to be
     * redrawn at default size unless
     * {@link javax.swing.JTextPane#getPreferredSize()} is called immediately
     * after actions that cause a repaint (such as setting the text).
     */
    private void preserveSize() {
        jTextPaneDesc.getPreferredSize();
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JTextPane jTextPaneDesc;
    // End of variables declaration//GEN-END:variables

    /**
     * Event fired when the text field of the {@link TextItem} has been updated
     * to reflect the data entered in the UI by the user.
     *
     * @author Timothy
     */
    public static class ItemTextUpdatedEvent extends EventObject {

        private final String newText;

        public ItemTextUpdatedEvent(Object source, String newText) {
            super(source);
            this.newText = newText;
        }

        public String getNewText() {
            return newText;
        }
    }

    /**
     * Listener interface for ItemTextUpdatedEvent events
     */
    public static interface ItemTextUpdateListener {

        public void textUpdated(ItemTextUpdatedEvent event);
    }

    private final ArrayList<ItemTextUpdateListener> listeners = new ArrayList<>();

    public void addItemTextUpdateListener(ItemTextUpdateListener l) {
        synchronized (listeners) {
            listeners.add(l);
        }
    }

    public void removeItemTextUpdateListener(ItemTextUpdateListener l) {
        synchronized (listeners) {
            listeners.remove(l);
        }
    }

    private void fireItemTextUpdatedEvent(String newText) {
        ItemTextUpdatedEvent event = new ItemTextUpdatedEvent(this, newText);
        synchronized (listeners) {
            for (ItemTextUpdateListener l : listeners) {
                l.textUpdated(event);
            }
        }
    }

    /**
     * This method should be called before storing the State to file to ensure
     * that any modifications in the current text field are stored to the State.
     */
    public static void ensureModificationsAreStored() {
        //NOTE: In most scenarios, it would be sufficient for the MainFrame to
        //  request focus or use KeyboardFocusManager.clearGlobalFocusOwner(). 
        //  However, doing that after the window closing action has fired
        //  doesn't seem to have any effect. Instead, we determine if some 
        //  instance of the 'jTextPaneDesc' owns the focus and directly call
        //  the saveAction() method on the parent.
        Component o = KeyboardFocusManager.getCurrentKeyboardFocusManager().getFocusOwner();
        if (o != null) {
            Container parent = o.getParent();
            if (parent instanceof EditableTextField) {
                ((EditableTextField) parent).saveAction();
            }
        }
    }
}
