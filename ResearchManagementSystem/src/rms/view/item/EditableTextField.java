package rms.view.item;

import java.awt.Color;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.util.ArrayList;
import java.util.EventObject;
import java.util.logging.Logger;
import javax.swing.JButton;
import javax.swing.Timer;
import javax.swing.UIDefaults;
import rms.model.item.TextItem;
import rms.view.util.CustomEditorKit;
import rms.view.util.UndoRedoProvider;

/**
 *
 * @author Timothy
 */
public class EditableTextField extends javax.swing.JPanel {

    private static final Logger thisLog = Logger.getLogger(EditableTextField.class.getName());

    private static final String SAVE = "Save";
    private static final String EDIT = "Edit";

    private final JButton saveEditButton;
    private final TextItem item;

    /**
     * No-arg constructor for Bean creation. NOTE: Do not use.
     */
    public EditableTextField() {
        saveEditButton = null;
        item = null;
        initComponents();
    }

    /**
     * Creates new form EditableTextField
     *
     * @param item
     * @param saveEditButton
     */
    public EditableTextField(TextItem item, JButton saveEditButton) {
        this.item = item;
        this.saveEditButton = saveEditButton;
        initComponents();
        if (saveEditButton != null && item != null) {
            initComponentsMore();
        }
    }

    private void initComponentsMore() {
        UndoRedoProvider.addTo(jTextPaneDesc);
        makeEditable(false);

        saveEditButton.addActionListener(new java.awt.event.ActionListener() {
            @Override
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                switch (saveEditButton.getText()) {
                    case SAVE:
                        saveAction();
                        break;
                    case EDIT:
                        editAction();
                        break;
                }
            }
        });
    }

    /**
     * Updates the UI using the current values of the Item fields.
     */
    public final void updateViewFromItem() {
        jTextPaneDesc.setText(item.getText());
        preserveSize();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jTextPaneDesc = new javax.swing.JTextPane();

        setPreferredSize(new java.awt.Dimension(6, 22));

        jTextPaneDesc.setEditable(false);
        jTextPaneDesc.setEditorKit(new CustomEditorKit(36));
        jTextPaneDesc.addFocusListener(new java.awt.event.FocusAdapter() {
            public void focusLost(java.awt.event.FocusEvent evt) {
                jTextPaneDescFocusLost(evt);
            }
        });
        jTextPaneDesc.addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyTyped(java.awt.event.KeyEvent evt) {
                jTextPaneDescKeyTyped(evt);
            }
        });

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jTextPaneDesc)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jTextPaneDesc)
        );
    }// </editor-fold>//GEN-END:initComponents

    private void jTextPaneDescFocusLost(java.awt.event.FocusEvent evt) {//GEN-FIRST:event_jTextPaneDescFocusLost
        if (evt.getOppositeComponent() != saveEditButton) {
            saveAction();
        }
    }//GEN-LAST:event_jTextPaneDescFocusLost

    private void jTextPaneDescKeyTyped(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_jTextPaneDescKeyTyped
        preserveSize();
    }//GEN-LAST:event_jTextPaneDescKeyTyped

    private void editAction() {
        saveEditButton.setText(SAVE);
        makeEditable(true);

        //Try requesting focus every 5 ms until successful
        final Timer focusTimer = new Timer(5, null);
        focusTimer.addActionListener(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
                if (jTextPaneDesc.requestFocusInWindow()) {
                    focusTimer.stop();
                }
            }
        });
        focusTimer.start();
    }

    private void saveAction() {
        saveEditButton.setText(EDIT);
        makeEditable(false);

        String newText = jTextPaneDesc.getText();
        if (!newText.equals(item.getText())) {
            item.replaceText(newText);
            _fireItemTextUpdatedEvent();
        }
    }

    private void makeEditable(boolean editable) {
        changeDescPaneColor(editable ? Color.WHITE : Color.LIGHT_GRAY);
        jTextPaneDesc.setEditable(editable);
        preserveSize();
    }

    private void changeDescPaneColor(Color c) {
        UIDefaults defaults = new UIDefaults();
        defaults.put("TextPane[Enabled].backgroundPainter", c);
        jTextPaneDesc.putClientProperty("Nimbus.Overrides", defaults);
        jTextPaneDesc.putClientProperty("Nimbus.Overrides.InheritDefaults", true);
        jTextPaneDesc.setBackground(c);
    }

    /**
     * There is a bug which causes the textPane to be redrawn at default size
     * unless getPreferredSize is called immediately after actions that cause a
     * repaint.
     */
    private void preserveSize() {
        jTextPaneDesc.getPreferredSize();
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JTextPane jTextPaneDesc;
    // End of variables declaration//GEN-END:variables

    /**
     * Event fired when the text field of the {@link TextItem} has been updated
     * to reflect the data entered in the UI by the user.
     *
     * @author Timothy
     */
    public static class ItemTextUpdatedEvent extends EventObject {

        private final String newText;

        public ItemTextUpdatedEvent(Object source, String newText) {
            super(source);
            this.newText = newText;
        }

        public String getNewText() {
            return newText;
        }
    }

    /**
     * Listener interface for ItemTextUpdatedEvent events
     */
    public static interface ItemTextUpdateListener {

        public void textUpdated(ItemTextUpdatedEvent event);
    }

    private final ArrayList<ItemTextUpdateListener> _listeners = new ArrayList<>();

    public synchronized void addItemTextUpdateListener(ItemTextUpdateListener l) {
        _listeners.add(l);
    }

    public synchronized void removeItemTextUpdateListener(ItemTextUpdateListener l) {
        _listeners.remove(l);
    }

    private synchronized void _fireItemTextUpdatedEvent() {
        ItemTextUpdatedEvent event = new ItemTextUpdatedEvent(this, item.getText());
        for (ItemTextUpdateListener l : _listeners) {
            l.textUpdated(event);
        }
    }
}
